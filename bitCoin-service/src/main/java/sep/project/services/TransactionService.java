package sep.project.services;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestClientException;
import org.springframework.web.client.RestTemplate;

import sep.project.dto.BitCoinPayment;
import sep.project.dto.PaymentRequestDTO;
import sep.project.dto.PaymentResponseDTO;
import sep.project.model.Merchant;
import sep.project.model.Transaction;
import sep.project.model.TransactionStatus;
import sep.project.repositories.TransactionRepository;

/**
 * Generated by Spring Data Generator on 20/12/2019
 */
@Service
public class TransactionService {

	private TransactionRepository transactionRepository;

	@Autowired
	private RestTemplate restTemplate;

	@Value("${sandbox_url}")
	private String sandBoxURL;

	@Value("Authorization")
	private String AUTH_HEADER;

	@Value("Bearer")
	private String TOKEN_TYPE;

	@Autowired
	public TransactionService(TransactionRepository transactionRepository) {
		this.transactionRepository = transactionRepository;
	}

	/**
	 * Metoda za pronalazak transakcije sa odgovarajucim id
	 * 
	 * @param id identifikator transakcije
	 * @return transakciju sa datim id-jem
	 */
	public Transaction getTransaction(Long id) {
		return this.transactionRepository.getOne(id);
	}

	/**
	 * Metoda za pronalazak transakcije sa odgovarajucim id placanja
	 * 
	 * @param id identifikator placanja
	 * @return transakciju sa datim id-jem placanja
	 */
	public Transaction getTransactionByPayment(Long id) {
		return this.transactionRepository.findByPaymentId(id);
	}

	public Transaction createInitialTransaction(Merchant merchant, BitCoinPayment paymentInfo) {
		Transaction transaction = new Transaction();
		transaction.setMerchant(merchant);
		transaction.setPriceAmount(paymentInfo.getPaymentAmount());
		transaction.setPriceCurrency(paymentInfo.getPaymentCurrency());
		transaction.setErrorUrl(paymentInfo.getErrorUrl());
		transaction.setSuccessUrl(paymentInfo.getSuccessUrl());
		transaction.setFailedUrl(paymentInfo.getFailedUrl());
		transaction.setOrderId(paymentInfo.getOrderId());
		Transaction saved = this.saveTransaction(transaction);

		return saved;
	}

	/**
	 * Metoda za cuvanje transakcije
	 * 
	 * @param transaction transakcija za cuvanje
	 * @return saƒçuvana transakcija
	 * @see Transaction
	 */
	public Transaction saveTransaction(Transaction transaction) {
		Transaction saved = null;
		try {
			saved = transactionRepository.save(transaction);
		} catch (Exception e) {
			return null;
		}

		return saved;
	}

	public Transaction findByOrderId(Long id) {
		return transactionRepository.findByOrderId(id);
	}

	public Transaction findMerchantTransactionBasedOnId(Long id, String email) {
		return transactionRepository.findMerchantTransactionBasedOnId(id, email);
	}
	
	/**
	 * Metoda za promenu stanja transakcije
	 * 
	 * @param id     identifikator transakcije kojoj je potrebno promeniti status
	 * @param status novi status transakcije
	 * @return true ukoliko je uspesno izmenjena transakcija u suprotnom false
	 */
	public boolean changeTransactionStatus(Long id, String status) {
		Transaction transaction = this.getTransaction(id);

		if (transaction == null)
			return false;

		transaction.setStatus(TransactionStatus.valueOf(status));
		transaction = this.saveTransaction(transaction);

		if (transaction == null)
			return false;

		return true;
	}

	/**
	 * Metoda za promenu transakcije na osnovu detalja o placanju
	 * 
	 * @param transaction transakcija
	 * @param dto         detalji placanja
	 * @return promenjena transakcija
	 */
	public Transaction changeTransaction(Transaction transaction, PaymentResponseDTO dto) {
		transaction.setCreationDate(dto.getCreated_at());
		transaction.setPaymentId(dto.getId());
		transaction.setStatus(TransactionStatus.valueOf(dto.getStatus().toUpperCase()));
		if (!dto.getReceive_amount().equals("")) {
			try {
				transaction.setReceiveAmount(Double.parseDouble(dto.getReceive_amount()));
			} catch (NumberFormatException e) {
				return null;
			}
		}
		transaction.setReceiveCurrency(dto.getReceive_currency());
		return this.saveTransaction(transaction);
	}

	/**
	 * Metoda za proveru stanja transakcije na coingate-u
	 * 
	 * @param transaction transakcija
	 * @return true- ukoliko je provera uspesno prosla, false - ukoliko je u toku
	 *         provere doslo do greske
	 */
	public boolean checkTransaction(Transaction transaction) {
		HttpHeaders headers = new HttpHeaders();
		headers.add(this.AUTH_HEADER, this.TOKEN_TYPE + " " + transaction.getMerchant().getToken());
		HttpEntity<PaymentRequestDTO> request = new HttpEntity<>(headers);
		ResponseEntity<PaymentResponseDTO> response = null;
		try {
			response = restTemplate.exchange("https://api-sandbox.coingate.com/v2/orders/" + transaction.getPaymentId(),
					HttpMethod.GET, request, PaymentResponseDTO.class);
		} catch (RestClientException e) {
			// TODO Auto-generated catch block
			return false;
		} catch (Exception e2) {
			return false;
		}

		PaymentResponseDTO responseObject = response.getBody();

		if (changeTransaction(transaction, responseObject) == null) {
			return false;
		}

		return true;
	}

	/**
	 * Metoda za periodicnu proveru transakcija sa statusom new, pending i
	 * confirming. Sinhronizacija sa stanjem transakcija na CoinGate-u
	 */
	@Scheduled(initialDelay = 10000, fixedRate = 60000)
	public void checkTransactionsStatuses() {
		List<Transaction> transactions = this.transactionRepository.getTransactionWithStatuses(TransactionStatus.NEW, TransactionStatus.PENDING, TransactionStatus.PENDING);

		for (Transaction transaction : transactions) {
			this.checkTransaction(transaction);
		}

	}

}
