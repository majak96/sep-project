package sep.project.services;

import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestClientException;
import org.springframework.web.client.RestTemplate;

import sep.project.controllers.PaymentController;
import sep.project.dto.PaymentRequestDTO;
import sep.project.dto.PaymentResponseDTO;
import sep.project.model.Merchant;
import sep.project.model.Transaction;
import sep.project.repositories.TransactionRepository;

/**
 * Generated by Spring Data Generator on 20/12/2019
 */
@Service
public class TransactionService {

	private static final Logger logger = LoggerFactory.getLogger(TransactionService.class);
	
	private TransactionRepository transactionRepository;

	@Autowired
	private RestTemplate restTemplate;

	@Value("${sandbox_url}")
	private String sandBoxURL;
	
	@Value("Authorization")
	private String AUTH_HEADER;
	
	@Value("Bearer")
	private String TOKEN_TYPE;

	@Autowired
	public TransactionService(TransactionRepository transactionRepository) {
		this.transactionRepository = transactionRepository;
	}

	/**
	 * Metoda za pronalazak transakcije sa odgovarajucim id
	 * @param id identifikator transakcije
	 * @return transakciju sa datim id-jem
	 */
	public Transaction getTransaction(Long id) {
		return this.transactionRepository.getOne(id);
	}
	
	/**
	 * Metoda za pronalazak transakcije sa odgovarajucim id placanja
	 * @param id identifikator placanja
	 * @return transakciju sa datim id-jem placanja
	 */
	public Transaction getTransactionByPayment(Long id) {
		return this.transactionRepository.findByPaymentId(id);
	}

	/**
	 * Metoda za kreiranje i čuvanje početne transakcije
	 * @param merchant prodavac
	 * @param paymentAmount cena za uplatu
	 * @param paymentCurrency valuta placanja
	 * @return sacuvana transakcija
	 * @see Merchant
	 * @see Transaction
	 */
	public Transaction createInitialTransaction(Merchant merchant, double paymentAmount, String paymentCurrency) {
		Transaction transaction = new Transaction();
		transaction.setMerchant(merchant);
		transaction.setPriceAmount(paymentAmount);
		transaction.setPriceCurrency(paymentCurrency);
		Transaction saved = this.saveTransaction(transaction);

		return saved;
	}

	/**
	 * Metoda za cuvanje transakcije
	 * @param transaction transakcija za cuvanje
	 * @return sačuvana transakcija
	 * @see Transaction
	 */
	public Transaction saveTransaction(Transaction transaction) {
		Transaction saved = null;
		try {
			saved = transactionRepository.save(transaction);
		} catch (Exception e) {
			return null;
		}

		return saved;
	}

	/**
	 * Metoda za promenu stanja transakcije
	 * @param id identifikator transakcije kojoj je potrebno promeniti status
	 * @param status novi status transakcije
	 * @return true ukoliko je uspesno izmenjena transakcija u suprotnom false
	 */
	public boolean changeTransactionStatus(Long id, String status) {
		Transaction transaction = this.getTransaction(id);

		if (transaction == null)
			return false;

		transaction.setStatus(status);
		transaction = this.saveTransaction(transaction);

		if (transaction == null)
			return false;

		return true;
	}
	
	public boolean changeTransaction(Transaction transaction) {
		HttpHeaders headers = new HttpHeaders();
		headers.add(this.AUTH_HEADER, this.TOKEN_TYPE + " " + transaction.getMerchant().getToken());
		HttpEntity<PaymentRequestDTO> request = new HttpEntity<>(headers);
		ResponseEntity<PaymentResponseDTO> response = null;
		
		try {
			response = restTemplate.exchange("https://api-sandbox.coingate.com/v2/orders/" + transaction.getPaymentId(), HttpMethod.GET, request,
						PaymentResponseDTO.class);
		} catch (RestClientException e) {
			// TODO Auto-generated catch block
			return false;
		} catch (Exception e2) {
			return false;
		}
		
		PaymentResponseDTO responseObject = response.getBody();
		System.out.println(responseObject);
		if(responseObject.getReceive_amount() != "") {
			try {
				transaction.setReceiveAmount(Double.parseDouble(responseObject.getReceive_amount()));
			} catch (NumberFormatException e) {
				// TODO Auto-generated catch block
				return false;
			}
		}

		transaction.setReceiveCurrency(responseObject.getReceive_currency());
		transaction.setStatus(responseObject.getStatus());
		transaction = this.saveTransaction(transaction);

		if (transaction == null) {
			return false;
		}
		
		return true;
	}

	/**
	 * Metoda za periodicnu proveru transakcija sa statusom new, pending i confirming.
	 * Sinhronizacija sa stanjem transakcija na CoinGate-u
	 */
	@Scheduled(initialDelay = 10000, fixedRate = 60000)
	public void checkTransactionsStatuses() {
		List<Transaction> transactions = this.transactionRepository.getTransactionWithStatuses("new", "pending",
				"confirming");
		
		for (Transaction transaction : transactions) {
			this.changeTransaction(transaction);
		}

	}

}
